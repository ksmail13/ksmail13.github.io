<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta name="google-site-verification" content="C06BO77KOqAeNb8oqCA4jHrmbcckq2yTDVQDTbBQjEY" />
    <meta name="naver-site-verification" content="63fa9b46362f4aff7e78c857ceb53fb60352e6c3" />

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-104476503-1"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-104476503-1');
    </script>

    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-NCDTGZ9');</script>
    <!-- End Google Tag Manager -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="그냥 자료정리하는 블로그">
    

    <!--Author-->
    
        <meta name="author" content="Minkyu Kim">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Kotlin - 6. Typesafe"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="그냥 자료정리하는 블로그" />
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="쌍떡잎식물"/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

        <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>Kotlin - 6. Typesafe - 쌍떡잎식물</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/style.css">


    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Google Analytics -->
    


    <!-- favicon -->
    
	
<meta name="generator" content="Hexo 5.4.1"></head>


<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NCDTGZ9"
        height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">쌍떡잎식물</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags">
                            
                                Tags
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/categories">
                            
                                Categories
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Kotlin - 6. Typesafe</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        
                            2021/10/20
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        


<a href="/tags/kotlin/">#kotlin</a> <a href="/tags/language/">#language</a> <a href="/tags/collection/">#collection</a>


                    
                </div>
                <div class="col-lg-4 col-md-5 post-categories">
                    
                        

<a href="/categories/language/">language</a>

                    
                </div>
            

            <!-- Gallery -->
            

            <!-- toc -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <h3>목차</h3>
                <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">최상위 Any, 최하위 Nothing</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">Any</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">Nothing</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">Nullable</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">null</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">nullable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">when</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">타입체크와 캐스팅</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">단순체크</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">그리고 스마트 캐스팅</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">명시적 타입 캐스팅</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">제네릭</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">타입 불변성</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">공변성</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">반공변성</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">where를 이용한 타입 제한</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">raw타입과 와일드카드</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">구체화된 타입 파라메터</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">출처</span></a></li></ol></li></ol></li></ol></li></ol>
            </div>

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <p>코틀린은 정적타입 언어입니다. 항상 타입은 고정되어 있고 그를 통해 잠재적인 오류가 발생하지 않도록 도와줍니다.<br>또한 기본적으로 nullsafe 를 지원하는 언어로 모든 타입은 기본적으로 null 을 사용할 수 없게 되어 있습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> s: String = <span class="number">1</span> <span class="comment">// ERROR</span></span><br><span class="line"><span class="keyword">val</span> s2: String = <span class="literal">null</span> <span class="comment">// ERROR</span></span><br></pre></td></tr></table></figure>

<p>이러한 특징 때문에 개발자는 함수의 형태 혹은 변수의 형태만 보고도 null에 대한 처리여부를 결정할 수 있기 때문에 코드를 작성하는데에 많은 이점이 생깁니다.</p>
<h1><span id="최상위-any-최하위-nothing">최상위 Any, 최하위 Nothing</span></h1><h2><span id="any">Any</span></h2><p>코틀린은 기본적으로 Any라는 타입을 상속받는 형태를 가집니다. 이는 자바의 Object와 같은 역할이라고 생각하시면 됩니다. 덕분에 모든 클래스는 자바처럼 equals, toString 같은 유틸리티 메소드를 가지게 됩니다. 그리고 추가적으로 지원하는 <a target="_blank" rel="noopener" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/#extension-functions">extention 함수</a>를 통해 여러가지 기본함수 역시 지원합니다.</p>
<h2><span id="nothing">Nothing</span></h2><p>Nothing은 자바에는 없는 코틀린 자체 클래스 입니다. 이름 그대로 아무런 값도 가지지 않는 타입으로 void 혹은 Unit 과 겹쳐 보일 수 있지만 이들과는 조금 다르다고 할 수 있습니다. 또한 Nothing 은 다른 클래스의 대체제로 사용 가능합니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Either</span>&lt;<span class="type">out L, out R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">map</span><span class="params">(r: (<span class="type">R</span>) -&gt; <span class="type">T</span>)</span></span>: Either&lt;L, T&gt; = flatMap &#123; Right(r(it)) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onLeft</span><span class="params">(e: (<span class="type">L</span>) -&gt; <span class="type">Unit</span>)</span></span>: Either&lt;L, R&gt; = <span class="keyword">when</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">is</span> Right -&gt; <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">is</span> Left -&gt; &#123;</span><br><span class="line">            e(lValue)</span><br><span class="line">            <span class="keyword">this</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Left</span>&lt;<span class="type">out L</span>&gt;</span>(<span class="keyword">val</span> lValue: L):Either&lt;L, <span class="built_in">Nothing</span>&gt;() <span class="comment">// 타입 파라메터 R을 대체</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Right</span>&lt;<span class="type">out R</span>&gt;</span>(<span class="keyword">val</span> rValue: R): Either&lt;<span class="built_in">Nothing</span>, R&gt;() <span class="comment">// 타입 파라메터 L을 대체</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;L, R, T&gt;</span> Either<span class="type">&lt;L, R&gt;</span>.<span class="title">flatMap</span><span class="params">(r: (<span class="type">R</span>) -&gt; <span class="type">Either</span>&lt;<span class="type">L</span>, T&gt;)</span></span>: Either&lt;L, T&gt; = <span class="keyword">when</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">is</span> Either.Right -&gt; r(rValue)</span><br><span class="line">    <span class="keyword">is</span> Either.Left -&gt; <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>위 Either 코드 처럼 제네릭 L, R을 필요에 따라 Nothing 으로 교체하여 사용하지 않을 타입에 대해선 무시할 수 있습니다.</p>
<h1><span id="nullable">Nullable</span></h1><h2><span id="null">null</span></h2><p><code>null</code>은 비어있는 변수(혹은 아무것도 가리키지 않는 레퍼런스)를 표현하는데에 최고의 표현식이지만 그로 인해 개발자가 고려해야 할 경우 수가 늘어납니다.</p>
<p>간단한 예로 특정 사용자가 인증을 거쳤는지 확인하는 코드를 봅시다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> connection.callQuery(selectUserQuery, id); <span class="comment">// It will return null when id isn&#x27;t exist.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUserAuthorized</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> user.isAuthorized();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// some method</span></span><br><span class="line">    isUserAuthorized(userRepository.getUser(id))</span><br></pre></td></tr></table></figure>

<p>위 예제에서 사용자의 인증여부를 확인하기 위해 조회를 하는데, 존재하지 않는 ID로 요청하는 경우 <code>isUserAuthroized</code> 메소드에서 NullPointerException이 발생 할 수 있습니다. Spring Framework 처럼 탄탄한 백그라운드가 있을 경우 ExceptionHandler 같은 어플리케이션 전반적으로 통제되는 에러핸들러를 통해 간단하게 처리가 가능하지만 그렇지 않은 경우엔 이런 예상하지 못한 에러를 안정적으로 처리하기 위해 더 많은 코드가 필요하게 됩니다. 따라서 대부분의 경우 아래와 같이 null 포인터 인지 확인 코드를 추가하게 됩니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUserAuthorized</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> user.isAuthorized();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위 예제는 하나의 객체를 대상으로 하는 메소드이기 때문에 단일 조건을 통한 if 문을 통해 스크리닝 가능하지만 여러객체를 취급하는 경우엔 모든 객체에 대한 null 체크가 필요하기 때문에, 조건문이 복잡해지게 됩니다.</p>
<p>자바에서는 null 에 대응하기 위해 두 가지 방법이 있습니다.</p>
<ol>
<li>Optional</li>
</ol>
<p>Optional은 <em>데이터가 존재하지 않을 수도 있다.</em> 를 표현해주는 클래스로 자바 8 버전에서 새롭게 추가된 클래스입니다. Optional을 이용해 위 예제를 아래와 같이 수정 할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;User&gt; <span class="title">getUser</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(connection.callQuery(selectUserQuery, id)); <span class="comment">// It will return null when id isn&#x27;t exist.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// v1 - modify isUserAuthorized itself</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUserAuthorized</span><span class="params">(Optional&lt;User&gt; userOptional)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userOptional.map(u -&gt; u.isAuthorized()).orElse(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v2 - modify when isUserAuthorized call</span></span><br><span class="line">userRepository.getUser(id).map(u -&gt; isUserAuthorized(u)).orElse(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
<p>getUser 에서 Optional로 감싼 User 객체를 리턴하게 변경했습니다.</p>
<p>첫번째 방식은 isUserAuthroized 메소드의 파라메터를 바꾼 형태, 두번째는 isUserAuthroized 메소드를 호출할 때의 형태를 바꾼 경우 입니다.<br>두 방식 모두 어떻게든 optional 을 풀어내 원하는 비지니스 로직을 실행해야 합니다. (다른 방식으로 isPresent를 이용한 방식도 있지만 코드 구성자체는 null 을 사용할 때와 동일하기 때문에 따로 기술하지 않았습니다.)</p>
<p>위 코드 처럼 Optional 을 적용 할 경우 <strong>추가 메소드 호출</strong>이 필요하며 <strong>호출 방식이 바뀐</strong>다는 점으로 앞서 if 문으로 null 체크로 하는 것보다 코드가 더 복잡해지며, 객체를 추가로 감싸는 형태이기 때문에 이를 처리하기 위한 약간의 <strong>오버헤드</strong>가 필요하며, 결국엔 객체이기 때문에 실수로 null 을 리턴하게 하더라도 <strong>컴파일러가 확인하지 않아</strong> 잠재적인 버그 포인트가 될 수 있습니다.</p>
<ol start="2">
<li>requireNonNull</li>
</ol>
<p><code>requireNonNull</code> 은 자바의 <code>Objects</code>(s 주의) 컴패니온 클래스에 있는 유틸리티 메소드로 파라메터가 null 일 경우 NPE를 바로 발생시키는 메소드 입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User userMustExist = Objects.requireNonNull(userRepository.getUser(id));</span><br><span class="line">isUserAuthorized(u);</span><br></pre></td></tr></table></figure>
<p>메소드가 실행된 이후에는 해당 객체가 무조건 객체가 존재함을 보장하며 별도의 객체를 사용하는것 아니기 때문에 앞서 살펴본 Optional 보다 간편하다는 장점이 있지만 결국 NPE를 일으킨다는 점에서 경우에 따라 해결책으로 보기는 어려워 보입니다.</p>
<p>코틀린은 어떨까요?<br>코틀린에서는 기본적으로 null을 사용할 수 없습니다. 따라서 모든 변수엔 무조건 객체가 할당되어야 합니다.<br>따라서 코틀린에서는 아래와 같이 해결할 수 있습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> NonExistUser: User(authorized = <span class="literal">false</span><span class="comment">/*, ...*/</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(id: <span class="type">String</span>)</span></span>: User = connection.callQuery(selectUserQuery, id)?: NonExistUser <span class="comment">// callQuery still can return null but ?: operator replace null to data that right of operator.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isUserAuthorized</span><span class="params">(u: <span class="type">User</span>)</span></span> = u.authorized</span><br></pre></td></tr></table></figure>

<p><code>object</code>는 코틀린에서 제공하는 싱글톤 생성 지시어로 특정 클래스를 싱글톤 형태로 만들어줍니다. 여기서는 존재하지 않는 사용자에 대해 임의의 싱글톤 객체 <code>NonExistUser</code>를 이용해 사용자가 없을 때 null 대신 사용하게 할 더미 객체로서 사용됩니다. 이로 인해 getUser 는 무조건 객체를 리턴함을 보장받고 getUser의 호출 부에는 별도의 null 체크 없이 객체 사용이 가능합니다.</p>
<h2><span id="nullable">nullable</span></h2><p>그렇다고 코틀린이 무조건 null 을 배척하지는 않습니다. Map 에서 키를 통해 데이터를 추출하거나, 자바와 연동되는 경우 null을 사용 할 수 도 있습니다. 그런 경우를 위해 코틀린에서는 별도의 Nullable 타입을 지원합니다. 사용법은 기존 타입에서 <code>?</code>가 추가된 형태로 사용됩니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> nullStr: String? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">val</span> normalString: String = <span class="literal">null</span> <span class="comment">// ERROR</span></span><br></pre></td></tr></table></figure>

<p>자바의 Optional과는 다르게 Nullable 타입은 컴파일 타임에 검사하기 때문에 좀 더 안전합니다.<br>위 사용자 인증 예제를 nullable 타입으로 교체하면 어떨까요?</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(id: <span class="type">String</span>)</span></span>: User? = connection.callQuery(selectUserQuery, id)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isUserAuthorized</span><span class="params">(u: <span class="type">User</span>?)</span></span>:<span class="built_in">Boolean</span>? = u?.authorized</span><br></pre></td></tr></table></figure>

<p>위에서 선언한 default객체는 제거하고 사용하는 메소드의 파라메터를 nullable하게 수정했습니다.</p>
<p>그리고 nullable 객체를 사용할 때 기존의 <code>.</code>가 아닌 <code>?.</code>인 다른 형태로 프로퍼티를 실행하는 것을 볼 수 있습니다. 이렇게 실행할 경우 null인 경우 실제 해당 객체에 접근하는것이 아닌 바로 null로 처리합니다. 아마 자바였다면 이렇게 표시되게 됩니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">isUserAuthorized</span><span class="params">(User u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> u.isAuthorized();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>만약 isUserAuthorized가 무조건 null이 아님을 보장하고 싶으면 어떻게 하면 될까요? 이럴 땐 첫번째 코틀린 예제에 나왔던 ?: 연산자(Elvis operator)를 사용하면 됩니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isUserAuthorized</span><span class="params">(u: <span class="type">User</span>?)</span></span>:<span class="built_in">Boolean</span> = u?.authorized ?: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>위 예제를 통해 u가 null일 때 false를 리턴하는것을 확인 할 수 있습니다.</p>
<h2><span id="when">when</span></h2><p>when을 이용하여 null값을 처리할 수도 있습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(id: <span class="type">String</span>)</span></span>: User? = connection.callQuery(selectUserQuery, id)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isUserAuthorized</span><span class="params">(u: <span class="type">User</span>?)</span></span>:<span class="built_in">Boolean</span>? = <span class="keyword">when</span>(u) &#123;</span><br><span class="line">    <span class="literal">null</span> -&gt; <span class="literal">false</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; u.authorized</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="타입체크와-캐스팅">타입체크와 캐스팅</span></h1><p>일반적인 객체지향 설계에서 타입체크를 한다는건 그렇게 좋은 신호는 아닙니다. 특정 상황에 특정 케이스에 대한 예외처리를 한다는 의미이기 때문에, 좋은 설계라고 보기도 힘들고 유지보수 부분에서도 이러한 복잡성을 고려해야하기 때문에 어렵다고 볼 수 있습니다.</p>
<p>그럼 우리는 무조건 타입을 지정하고 사용할까요? 원청에서 내려준 API의 결과가 복잡한 구조지만 결과가 제멋대로 바뀌는 JSON 문서를 처리할 때 우리는 <code>Map&lt;String, Any&gt;</code>으로 받아 처리하는 방향으로 화를 삭힙니다. 그리고 객체지향에서 벗어났을 때 타입체크는 또다른 사용성을 보여줍니다.</p>
<h2><span id="단순체크">단순체크</span></h2><p>단순히 특정 객체의 타입을 체크하기 위해서는 <code>is</code>라는 연산자를 사용합니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> o: Any = <span class="string">&quot;any string&quot;</span></span><br><span class="line"></span><br><span class="line">println(o <span class="keyword">is</span> String) <span class="comment">// true</span></span><br><span class="line">println(o <span class="keyword">is</span> Any) <span class="comment">// true</span></span><br><span class="line">println(o <span class="keyword">is</span> <span class="built_in">Int</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3><span id="그리고-스마트-캐스팅">그리고 스마트 캐스팅</span></h3><p>코틀린의 컴파일러는 자바의 것보다 똑똑합니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> o: Any = something</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (o <span class="keyword">is</span> String) &#123;</span><br><span class="line">    println(o.length)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">is</span> <span class="built_in">Int</span>) &#123;</span><br><span class="line">    println(o)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;Unexpected value type&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>자바였으면 o를 사용하기 전에 확인된 타입으로 타입캐스팅이 필요했지만 코틀린에서는 알아서 컴파일러가 해당 타입을 추론하여 변수의 타입을 특정 타입으로 인정해줍니다.<br>이는 아래의 when 문으로 정리할 수 있습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> o: Any = something</span><br><span class="line"></span><br><span class="line">println(<span class="keyword">when</span>(o) &#123; </span><br><span class="line">    <span class="keyword">is</span> String -&gt; o.length</span><br><span class="line">    <span class="keyword">is</span> <span class="built_in">Int</span> -&gt; o</span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;Unexpected value type&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>각 세부 조건 절의 조건인 타입체크문을 통해서 해당 절의 when의 검사 대상 객체의 타입을 임의로 바꾸어 실행됨을 알 수 있습니다.</p>
<h1><span id="명시적-타입-캐스팅">명시적 타입 캐스팅</span></h1><p>명시적인 타입캐스팅은 <code>as</code> 연산자를 통해 이루어집니다.<br>일반적으로 스마트 캐스팅을 적용하기 어려울 때 사용합니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> o: Any = something</span><br><span class="line"></span><br><span class="line">(o <span class="keyword">as</span> SomeClass).doSomething()</span><br></pre></td></tr></table></figure>

<p>만약 위 예제에서 something이라는 변수가 SomeClass가 아니라면 ClassCaseException이 발생합니다.<br>만약 이를 회피하고 싶다면 <code>as?</code> 연산자를 사용할 수 있습니다. 이 연산자는 물음표에서 예상 할 수 있듯이 타입이 맞지 않을 경우 null을 리턴합니다.</p>
<h1><span id="제네릭">제네릭</span></h1><p>kotlin도 여타 다른 언어처럼 제네릭을 지원합니다.<br>기존 자바에서 지원하는 공변성(&lt;? extends T&gt;)은 out 이라는 키워드로 정의할 수 있고<br>반공변성(&lt;? super T&gt;)의 경우 in 이라는 키워드로 정의 할 수 있습니다.</p>
<h2><span id="타입-불변성">타입 불변성</span></h2><p>일반적인 클래스를 받는 메소드를 작성했을 때, 해당 클래스를 상속받은 클래스를 메소드로 넘기는 것엔 크게 문제가 되지 않습니다. 다만 제네릭에서는 조금 다릅니다.<br>List<object>는 String 데이터를 받을 수 있지만 이 객체를 받는 메소드는 List<string>를 받지 못하는 것 처럼 특정 클래스를 감싼 제네릭 클래스를 분리 시키는 특징을 타입 불변성이라고 합니다.</string></object></p>
<p>Array를 예로 들면</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">process</span><span class="params">(objs: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">process(arrayOf&lt;String&gt;(<span class="string">&quot;1&quot;</span>)) <span class="comment">// ERROR</span></span><br></pre></td></tr></table></figure>

<p><code>Array&lt;Any&gt;</code> 와 <code>Array&lt;String&gt;</code>에서 String은 Any의 자식 클래스이기 때문에 가능할 것 같지만 타입불변성에 의해 불가능합니다. 참고로 자바 배열은 경우에도 컴파일러가 막지 않습니다.</p>
<p>만약 위를 허용하게 된다면 파라메터로 넘어간 Array 내부에 기존에 정의된 타입과 다른 타입이 할당 될 수 있다는 문제가 있습니다. 자바의 경우 이럴 때 <code>ArrayStoreException</code>이 런타임에 발생하게 됩니다. 네 런타임에 발생하기 때문에 잠재적인 오류 포인트가 될 수 있습니다.(물론 이렇게 쓰는 사람은 별로 없죠)</p>
<p>List는 어떨까요? 자바에서는 당연히 막힙니다. 하지만 코틀린은 다릅니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">process</span><span class="params">(objList: <span class="type">List</span>&lt;<span class="type">Any</span>&gt;)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">process(listOf&lt;String&gt;(<span class="string">&quot;1&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>코틀린은 위 상황에서 오류를 발생하지 않습니다. 코틀린의 List는 내부 데이터가 변할일이 없기 때문에 이를 허용하도록 선언되어 있습니다. 따라서 데이터 수정이 가능한 MutableList는 타입 불변성을 유지합니다.</p>
<h2><span id="공변성">공변성</span></h2><p>공변성은 위에서 하지못했던 일을 가능하게 해줍니다. 또한 List의 비밀도 여기서 밝혀집니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">process</span><span class="params">(objs: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">Any</span>&gt;)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">process(arrayOf&lt;String&gt;(<span class="string">&quot;1&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>선언시에 타입 파라메터에 out 지시어를 추가함으로서 이 타입에 공변성을 추가합니다. 따라서 Any의 자식 클래스인 String의 Array도 받을 수 있게 됩니다. 하지만 여기에 process 함수 내에서 데이터 수정하려고 하면 실패하게 됩니다. 타입을 확인해보면 Nothing타입만 받을 수 있다고 나옵니다. 네 이렇게 받은 파라메터는 내부 데이터를 수정할 수 없게 됩니다.</p>
<h2><span id="반공변성">반공변성</span></h2><p>공변성에 반대되는 반공변성은 in이라는 지시어로 표시 되며, 특정클래스의 상위타입들을 타입 파라메터으로 가지고 있는 객체들을 받을 수 있습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">process2</span><span class="params">(objs: <span class="type">MutableList</span>&lt;<span class="type">in</span> <span class="type">Int</span>&gt;)</span></span>: MutableList&lt;<span class="keyword">in</span> <span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    objs.add(Random(System.currentTimeMillis()).nextInt())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> process2: MutableList&lt;<span class="keyword">in</span> <span class="built_in">Int</span>&gt; = process2(mutableListOf&lt;Number&gt;())</span><br><span class="line"></span><br><span class="line">process2.add(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>또한 위 예제처럼 객체 내부 데이터도 수정할 수 있습니다. 이때 추가할 수 있는 객체는 타입 파라메터입니다. (위 예시에서는 Int) 다만 이상태에서 get등을 이용하여 데이터를 사용할 때는 Any 타입으로 인식 됩니다. 어디까지나 제네릭타입이 상속받는 클래스을 나타내기 때문입니다.</p>
<h2><span id="where를-이용한-타입-제한">where를 이용한 타입 제한</span></h2><p>자바에서 다중 타입에 대한 타입 파라메터 제한은 &amp; 라는 키워드로 표현됩니다. 코틀린에서는 where이라는 키워드로 표현됩니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">process</span><span class="params">(t: <span class="type">T</span>)</span></span> <span class="keyword">where</span> T: Appendable, T: Closable &#123;</span><br><span class="line">    t.append(...)</span><br><span class="line">    t.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>where 키워드 이후에 타입에 대한 제한조건을 콤마로 나누어 정의하면 됩니다.</p>
<h2><span id="raw타입과-와일드카드">raw타입과 와일드카드</span></h2><p>자바는 제네릭타입을 가지는 클래스에 아무것도 지정하지 않는 방식으로 객체를 초기화 할 수 있습니다. raw타입이라고 불리는 이 타입은 프로젝트 내부에 타입안정성을 해치는 방식이기 때문에 코틀린에서는 따로 지원하지 않습니다. 대신 자바의 <code>?</code> 처럼 <code>*</code> 라는 와일드카드를 지원합니다. 와일드카드를 통해 모든 타입을 받을 수 있지만 공변성처럼 데이터를 추가할 수 없는 상태가 되며, 내부 데이터 역시 Any로 처리 됩니다.</p>
<h2><span id="구체화된-타입-파라메터">구체화된 타입 파라메터</span></h2><p>자바에서 jackson을 통해 json 데이터를 특정 객체로 변환할 때 우리는 클래스의 구조를 내부 메소드로 전달하기 위해 클래스의 메타데이터 객체를 같이 전달합니다.<br>코틀린에서는 이와 같은 불필요한 데이터 전달을 막기 위해 구체화된 타입 파라메터 기능을 제공합니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">parse</span><span class="params">(json: <span class="type">String</span>)</span></span>: T = objectMapper.readValue(json, T::<span class="class"><span class="keyword">class</span>)</span></span><br></pre></td></tr></table></figure>

<p>타입 파라메터 앞에 <code>reified</code> 라는 지시어를 추가하여 함수 내부에서 구체화된 파라메터 T를 선언합니다. 그리고 메소드 내부에 보시면 T에서 해당 클래스의 메타데이터를 추출할 수 있습니다.</p>
<p>구체화는 인라인 함수에서만 쓸 수 있는데, 이는 컴파일 타임에 해당 타입을 추론하여 함수 호출 부에 함수 내용을 변환하여 사용하는 형태를 가지게 됩니다.</p>
<h4><span id="출처">출처</span></h4><ul>
<li>다재다능 코틀린 프로그래밍</li>
<li>코틀린 공식 문서</li>
</ul>


                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    




    <hr />
    <div class="utterance"></div>

    <script src="https://utteranc.es/client.js"
        repo="ksmail13/ksmail13.github.io"
        issue-term="pathname"
        label="comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
    </script>


                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/ksmail13" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    
                        <li>
                            <a href="mailto:ksmail13@gmail.com" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-envelope-o fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2022 Minkyu Kim<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/">Clean Blog</a> from <a href="http://startbootstrap.com/" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/">Hexo</a> by <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>